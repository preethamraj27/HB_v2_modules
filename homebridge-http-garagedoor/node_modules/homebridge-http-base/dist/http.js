"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.multipleHttpRequests = exports.httpRequest = exports.isHttpRedirectCode = exports.isHttpSuccessCode = exports.setMultipleUrlExecutionStrategy = exports.ExecutionStrategy = void 0;
const async = require("async");
const request = require("request");
const delayPattern = /^delay\(\d+\)*$/;
const numberPattern = /\d+/;
class ExecutionStrategy {
    static get(name) {
        name = name.toUpperCase();
        switch (name) {
            case "PARALLEL":
                return this.PARALLEL;
            case "SERIES":
                return this.SERIES;
            default:
                return null;
        }
    }
}
exports.ExecutionStrategy = ExecutionStrategy;
ExecutionStrategy.PARALLEL = async.parallel;
ExecutionStrategy.SERIES = async.series;
let multipleUrlExecutionStrategy = ExecutionStrategy.PARALLEL;
function setMultipleUrlExecutionStrategy(strategyString) {
    const strategy = ExecutionStrategy.get(strategyString);
    if (strategy) {
        multipleUrlExecutionStrategy = strategy;
        return true;
    }
    return false;
}
exports.setMultipleUrlExecutionStrategy = setMultipleUrlExecutionStrategy;
function isHttpSuccessCode(statusCode) {
    return Math.floor(statusCode / 100) === 2;
}
exports.isHttpSuccessCode = isHttpSuccessCode;
function isHttpRedirectCode(statusCode) {
    return Math.floor(statusCode / 100) === 3;
}
exports.isHttpRedirectCode = isHttpRedirectCode;
function httpRequest(urlObject, callback, ...bodyReplacer) {
    let url = urlObject.url;
    let body = urlObject.body;
    let auth = undefined;
    if (urlObject.auth && urlObject.auth.username && urlObject.auth.password) {
        auth = {
            username: urlObject.auth.username,
            password: urlObject.auth.password
        };
        if (typeof urlObject.auth.sendImmediately !== "undefined")
            auth.sendImmediately = urlObject.auth.sendImmediately;
    }
    bodyReplacer.forEach(replacer => {
        url = url.replace(replacer.searchValue, replacer.replacer);
        if (body) {
            body = body.replace(replacer.searchValue, replacer.replacer);
        }
    });
    request({
        url: url,
        body: body,
        method: urlObject.method || "GET",
        headers: urlObject.headers,
        auth: auth,
        strictSSL: urlObject.strictSSL,
        timeout: urlObject.requestTimeout || 20000,
    }, (error, response, body) => {
        callback(error, response, body);
    });
}
exports.httpRequest = httpRequest;
function multipleHttpRequests(urlObjectArray, callback) {
    if (urlObjectArray.length === 0)
        throw new Error("Empty urlObject array");
    const taskArray = []; //Array<AsyncFunction<T, E>
    const executionCounter = [];
    for (let i = 0; i < urlObjectArray.length; i++) {
        const urlObject = urlObjectArray[i];
        if (executionCounter[i] === undefined)
            executionCounter[i] = urlObject.repeat;
        taskArray.push((callback, delayed) => {
            if (urlObject.url.startsWith("delay") && delayPattern.test(urlObject.url)) {
                if (multipleUrlExecutionStrategy !== ExecutionStrategy.SERIES) {
                    console.warn("There was a 'delay' method specified but execution is unaffected because of unsuitable execution strategy!");
                    callback();
                    return;
                }
                const delay = parseInt(urlObject.url.match(numberPattern)[0]);
                // execute callback from async framework => finish urlObject
                setTimeout(() => callback(), delay);
                return;
            }
            if (!delayed && urlObject.delayBeforeExecution > 0) {
                const self = arguments.callee;
                // execute the current method a second time though delayed=true
                setTimeout(() => self(callback, true), urlObject.delayBeforeExecution);
                return;
            }
            httpRequest(urlObject, callback);
        });
        executionCounter[i]--;
        if (executionCounter[i] > 0)
            i--; // repeat current urlObject
    }
    // (err?: E | null, results?: Array<T | undefined>): void;
    // Array<(callback: (err: null, result: {error?: E, value?: T})
    // result: export interface AsyncResultArrayCallback<T, E = Error> { (err?: E | null, results?: Array<T | undefined>): void; }
    multipleUrlExecutionStrategy(async.reflectAll(taskArray), (error, results) => {
        const callbackArray = [];
        for (let i = 0; i < results.length; i++) {
            const element = results[i];
            if (element.error) {
                callbackArray.push({
                    error: element.error
                });
            }
            else if (element.value) {
                callbackArray.push({
                    response: element.value[0],
                    body: element.value[1]
                });
            }
        }
        callback(callbackArray);
    });
}
exports.multipleHttpRequests = multipleHttpRequests;
//# sourceMappingURL=http.js.map